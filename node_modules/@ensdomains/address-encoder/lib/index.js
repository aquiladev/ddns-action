"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var bech32 = require("bech32");
var bs58check = require("bs58check");
var cashaddr = require("cashaddrjs");
var eos = require("eosjs-ecc");
var nemSdk = require("nem-sdk");
var ripple = require("ripple-address-codec");
var rsk = require("rskjs-util");
var stellar = require("stellar-base");
var tronweb = require("tronweb");
function makeBase58CheckEncoder(p2pkhVersion, p2shVersion) {
    return function (data) {
        var addr;
        switch (data.readUInt8(0)) {
            case 0x76: // P2PKH: OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG
                if (data.readUInt8(1) !== 0xa9 ||
                    data.readUInt8(data.length - 2) !== 0x88 ||
                    data.readUInt8(data.length - 1) !== 0xac) {
                    throw Error('Unrecognised address format');
                }
                addr = Buffer.concat([Buffer.from([p2pkhVersion]), data.slice(3, 3 + data.readUInt8(2))]);
                return bs58check.encode(addr);
            case 0xa9: // P2SH: OP_HASH160 <scriptHash> OP_EQUAL
                if (data.readUInt8(data.length - 1) !== 0x87) {
                    throw Error('Unrecognised address format');
                }
                addr = Buffer.concat([Buffer.from([p2shVersion]), data.slice(2, 2 + data.readUInt8(1))]);
                return bs58check.encode(addr);
            default:
                throw Error('Unrecognised address format');
        }
    };
}
function makeBase58CheckDecoder(p2pkhVersions, p2shVersions) {
    return function (data) {
        var addr = bs58check.decode(data);
        var version = addr.readUInt8(0);
        if (p2pkhVersions.includes(version)) {
            return Buffer.concat([Buffer.from([0x76, 0xa9, 0x14]), addr.slice(1), Buffer.from([0x88, 0xac])]);
        }
        else if (p2shVersions.includes(version)) {
            return Buffer.concat([Buffer.from([0xa9, 0x14]), addr.slice(1), Buffer.from([0x87])]);
        }
        throw Error('Unrecognised address format');
    };
}
var base58Chain = function (name, coinType, p2pkhVersions, p2shVersions) { return ({
    coinType: coinType,
    decoder: makeBase58CheckDecoder(p2pkhVersions, p2shVersions),
    encoder: makeBase58CheckEncoder(p2pkhVersions[0], p2shVersions[0]),
    name: name,
}); };
function makeBech32SegwitEncoder(hrp) {
    return function (data) {
        var version = data.readUInt8(0);
        if (version >= 0x51 && version <= 0x60) {
            version -= 0x50;
        }
        else if (version !== 0x00) {
            throw Error('Unrecognised address format');
        }
        var words = [version].concat(bech32.toWords(data.slice(2, data.readUInt8(1) + 2)));
        return bech32.encode(hrp, words);
    };
}
function makeBech32SegwitDecoder(hrp) {
    return function (data) {
        var _a = bech32.decode(data), prefix = _a.prefix, words = _a.words;
        if (prefix !== hrp) {
            throw Error('Unexpected human-readable part in bech32 encoded address');
        }
        var script = bech32.fromWords(words.slice(1));
        var version = words[0];
        if (version > 0) {
            version += 0x50;
        }
        return Buffer.concat([Buffer.from([version, script.length]), Buffer.from(script)]);
    };
}
function makeBitcoinEncoder(hrp, p2pkhVersion, p2shVersion) {
    var encodeBech32 = makeBech32SegwitEncoder(hrp);
    var encodeBase58Check = makeBase58CheckEncoder(p2pkhVersion, p2shVersion);
    return function (data) {
        try {
            return encodeBase58Check(data);
        }
        catch (_a) {
            return encodeBech32(data);
        }
    };
}
function makeBitcoinDecoder(hrp, p2pkhVersions, p2shVersions) {
    var decodeBech32 = makeBech32SegwitDecoder(hrp);
    var decodeBase58Check = makeBase58CheckDecoder(p2pkhVersions, p2shVersions);
    return function (data) {
        if (data.toLowerCase().startsWith(hrp + '1')) {
            return decodeBech32(data);
        }
        else {
            return decodeBase58Check(data);
        }
    };
}
var bitcoinChain = function (name, coinType, hrp, p2pkhVersions, p2shVersions) { return ({
    coinType: coinType,
    decoder: makeBitcoinDecoder(hrp, p2pkhVersions, p2shVersions),
    encoder: makeBitcoinEncoder(hrp, p2pkhVersions[0], p2shVersions[0]),
    name: name,
}); };
function encodeCashAddr(data) {
    switch (data.readUInt8(0)) {
        case 0x76: // P2PKH: OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG
            if (data.readUInt8(1) !== 0xa9 ||
                data.readUInt8(data.length - 2) !== 0x88 ||
                data.readUInt8(data.length - 1) !== 0xac) {
                throw Error('Unrecognised address format');
            }
            return cashaddr.encode('bitcoincash', 'P2PKH', data.slice(3, 3 + data.readUInt8(2)));
        case 0xa9: // P2SH: OP_HASH160 <scriptHash> OP_EQUAL
            if (data.readUInt8(data.length - 1) !== 0x87) {
                throw Error('Unrecognised address format');
            }
            return cashaddr.encode('bitcoincash', 'P2SH', data.slice(2, 2 + data.readUInt8(1)));
        default:
            throw Error('Unrecognised address format');
    }
}
function decodeCashAddr(data) {
    var _a = cashaddr.decode(data), prefix = _a.prefix, type = _a.type, hash = _a.hash;
    if (type === 'P2PKH') {
        return Buffer.concat([Buffer.from([0x76, 0xa9, 0x14]), Buffer.from(hash), Buffer.from([0x88, 0xac])]);
    }
    else if (type === 'P2SH') {
        return Buffer.concat([Buffer.from([0xa9, 0x14]), Buffer.from(hash), Buffer.from([0x87])]);
    }
    throw Error('Unrecognised address format');
}
function decodeBitcoinCash(data) {
    var decodeBase58Check = makeBase58CheckDecoder([0x00], [0x05]);
    try {
        return decodeBase58Check(data);
    }
    catch (_a) {
        return decodeCashAddr(data);
    }
}
function makeChecksummedHexEncoder(chainId) {
    return function (data) { return rsk.toChecksumAddress(data.toString('hex'), chainId || null); };
}
function makeChecksummedHexDecoder(chainId) {
    return function (data) {
        var stripped = rsk.stripHexPrefix(data);
        if (!rsk.isValidChecksumAddress(data, chainId || null) &&
            stripped !== stripped.toLowerCase() &&
            stripped !== stripped.toUpperCase()) {
            throw Error('Invalid address checksum');
        }
        return Buffer.from(rsk.stripHexPrefix(data), 'hex');
    };
}
var hexChecksumChain = function (name, coinType, chainId) { return ({
    coinType: coinType,
    decoder: makeChecksummedHexDecoder(chainId),
    encoder: makeChecksummedHexEncoder(chainId),
    name: name,
}); };
function makeBech32Encoder(prefix) {
    return function (data) { return bech32.encode(prefix, bech32.toWords(data)); };
}
function makeBech32Decoder(currentPrefix) {
    return function (data) {
        var _a = bech32.decode(data), prefix = _a.prefix, words = _a.words;
        if (prefix !== currentPrefix) {
            throw Error('Unrecognised address format');
        }
        return Buffer.from(bech32.fromWords(words));
    };
}
var bech32Chain = function (name, coinType, prefix) { return ({
    coinType: coinType,
    decoder: makeBech32Decoder(prefix),
    encoder: makeBech32Encoder(prefix),
    name: name,
}); };
function b32encodeXemAddr(data) {
    return nemSdk.default.model.address.b32encode(nemSdk.default.utils.convert.hex2a(data));
}
function b32decodeXemAddr(data) {
    if (!nemSdk.default.model.address.isValid(data)) {
        throw Error('Unrecognised address format');
    }
    var address = data.toString().toUpperCase().replace(/-/g, '');
    return nemSdk.default.utils.convert.ua2hex(nemSdk.default.model.address.b32decode(address));
}
function eosAddrEncoder(data) {
    if (!eos.PublicKey.isValid(data)) {
        throw Error('Unrecognised address format');
    }
    return eos.PublicKey.fromHex(data).toString();
}
function eosAddrDecoder(data) {
    if (!eos.PublicKey.isValid(data)) {
        throw Error('Unrecognised address format');
    }
    return eos.PublicKey(data).toBuffer();
}
var formats = [
    bitcoinChain('BTC', 0, 'bc', [0x00], [0x05]),
    bitcoinChain('LTC', 2, 'ltc', [0x30], [0x32, 0x05]),
    base58Chain('DOGE', 3, [0x1e], [0x16]),
    base58Chain('DASH', 5, [0x4c], [0x10]),
    bitcoinChain('MONA', 22, 'mona', [0x32], [0x37, 0x05]),
    {
        coinType: 43,
        decoder: b32decodeXemAddr,
        encoder: b32encodeXemAddr,
        name: 'XEM',
    },
    hexChecksumChain('ETH', 60),
    hexChecksumChain('ETC', 61),
    bech32Chain('ATOM', 118, 'cosmos'),
    hexChecksumChain('RSK', 137, 30),
    {
        coinType: 144,
        decoder: function (data) { return ripple.codec.decodeChecked(data); },
        encoder: function (data) { return ripple.codec.encodeChecked(data); },
        name: 'XRP',
    },
    {
        coinType: 145,
        decoder: decodeBitcoinCash,
        encoder: encodeCashAddr,
        name: 'BCH',
    },
    {
        coinType: 148,
        decoder: stellar.StrKey.decodeEd25519PublicKey,
        encoder: stellar.StrKey.encodeEd25519PublicKey,
        name: 'XLM',
    },
    {
        coinType: 194,
        decoder: eosAddrDecoder,
        encoder: eosAddrEncoder,
        name: 'EOS',
    },
    {
        coinType: 195,
        decoder: tronweb.address.toHex,
        encoder: tronweb.address.fromHex,
        name: 'TRX',
    },
    {
        coinType: 714,
        decoder: function (data) {
            var _a = bech32.decode(data), prefix = _a.prefix, words = _a.words;
            if (prefix !== 'bnb') {
                throw Error('Unrecognised address format');
            }
            return Buffer.from(bech32.fromWords(words));
        },
        encoder: function (data) {
            return bech32.encode('bnb', bech32.toWords(data));
        },
        name: 'BNB',
    },
    hexChecksumChain('XDAI', 700),
    bech32Chain('BNB', 714, 'bnb'),
];
exports.formatsByName = Object.assign.apply(Object, __spreadArrays([{}], formats.map(function (x) {
    var _a;
    return (_a = {}, _a[x.name] = x, _a);
})));
exports.formatsByCoinType = Object.assign.apply(Object, __spreadArrays([{}], formats.map(function (x) {
    var _a;
    return (_a = {}, _a[x.coinType] = x, _a);
})));
